reviews_db = [
    {"code": "user, status_code = auth_services.auth_user(user)",
     "review": "TODO: auth_services зависимости нужно передвать через DI"},
    {"code": "message["contact_us"] = current_app.config["ANUNBIS_FRONTEND_URI"]",
     "review": "TODO: нужно передавать через DI"},
    {"code": "from fastapi import FastAPI",
     "review": "TODO: ps. в идеале заменить FastAPI на Falcon"},
    {"code": "class BaseConfig:
    TITLE = "Anunbis"
    JSON_AS_ASCII = False
    MAIL_DEBUG = True
    ANUNBIS_FRONTEND_URI = os.getenv("ANUNBIS_FRONTEND_URI", "localhost:3000")
    ANUNBIS_BACKEND_URI = os.getenv("ANUNBIS_BACKEND_URI", "localhost:5000")
    ANUNBIS_VERSION = os.getenv("ANUNBIS_VERSION", "0.1.0")
    SWAGGER = swagger.config_specs_dict(
        ANUNBIS_FRONTEND_URI=ANUNBIS_FRONTEND_URI, ANUNBIS_VERSION=ANUNBIS_VERSION
    )",
     "review": "TODO: Необходимо использовать pydantic модели, настройки должны быть в .env, настройки должны быть отнесенны к модулям к которым они относятся"},
    {"code": "class DevConfig(BaseConfig):
    DEBUG = os.getenv("FLASK_DEBUG") == "1"
    SQLALCHEMY_DATABASE_URI = os.getenv("FLASK_SQLALCHEMY_DATABASE_URI")
    SQLALCHEMY_TRACK_MODIFICATIONS = os.getenv("SQLALCHEMY_TRACK_MODIFICATIONS", True)
    SECRET_KEY = os.getenv("FLASK_SECRET_KEY")
    JWT_ACCESS_TOKEN_EXPIRES = timedelta(hours=int(os.getenv("TOKEN_EXPIRES_HOURS", 1)))
    MAIL_SERVER = os.getenv("MAIL_SERVER")
    MAIL_PORT = int(os.getenv("MAIL_PORT", 465))
    MAIL_USE_SSL = os.getenv("MAIL_USE_SSL") == "1"
    MAIL_DEBUG = os.getenv("MAIL_DEBUG") == "1"
    MAIL_USERNAME = os.getenv("MAIL_USERNAME", "example@gmail.com")
    MAIL_DEFAULT_SENDER = MAIL_USERNAME
    MAIL_PASSWORD = os.getenv("MAIL_PASSWORD", "password")
    MAIL_SUPPRESS_SEND = os.getenv("MAIL_SUPPRESS_SEND", "1") == "1"",
     "review": "TODO: Необходимо использовать pydantic модели, настройки должны быть в .env, настройки должны быть отнесенны к модулям к которым они относятся"},
    {"code": "class TestConfig(BaseConfig):
    TESTING = True
    JWT_SECRET_KEY = "anunbis-test"
    PRESERVE_CONTEXT_ON_EXCEPTION = False
    SQLALCHEMY_DATABASE_URI = "sqlite:///"
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    MAIL_SUPPRESS_SEND = True
    MAIL_USERNAME = "test@gmail.com"
    MAIL_DEFAULT_SENDER = MAIL_USERNAME
    MAIL_PASSWORD = "password"
    MAIL_SERVER = "smtp.gmail.com"
    MAIL_PORT = 465",
     "review": "TODO: Необходимо использовать pydantic модели, настройки должны быть в .env, настройки должны быть отнесенны к модулям к которым они относятся"},
    {"code": "return {"message": "User's email not actived. Please, active your e-mail!"}, 203",
     "review": "TODO: HTTP код ответа нужно расместить в контроллерах"},
    {"code": "return {"message": "Email or Password invalid"}, 401",
     "review": "TODO: HTTP код ответа нужно расместить в контроллерах"},
    {"code": "rest_api.add_resource(users_api.UserAPI, '/api/v1/user')
rest_api.add_resource(users_api.AuthenticationAPI, '/api/v1/authenticate')
rest_api.add_resource(users_api.PasswordResetRequestAPI, '/api/v1/password-reset/request')
rest_api.add_resource(users_api.PasswordResetConfirmAPI, '/api/v1/password-reset/confirm')
rest_api.add_resource(users_api.AdminOnlyAPI, '/api/v1/admin')",
     "review": "TODO переделать в метод - фабрику"},
    {"code": "    def post(self):
        args = self.req_parser.parse_args()

        user = AppUser(email=args['email'], password=args['password'])
        db.session.add(user)",
     "review": "TODO судя по всему необходим декоратор @auth_required"},
    {"code": "        try:
            db.session.commit()",
     "review": "TODO Не стоит управлять транзакцией внутри каждого обработчика запросов. Это приведет к дублированию кода. Эту функциональность можно вынести в декоратор либо в базовый класс контроллера запросов."},
    {"code": "        except IntegrityError:
            return EMAIL_IN_USE",
     "review": "TODO Следует применять централизованный обработчик ошибок"},
    {"code": "return {'id': user.id, 'token': generate_token(user)}, 201",
     "review": "TODO Необходимо использовать код успешного завершения запроса по умолчанию централизованно, чтобы не указывать его каждый раз. Код ответа можно поместить в константы."},
    {"code": "user = db.session.query(AppUser).filter(AppUser.email==args['email']).first()",
     "review": "TODO Не стоит формировать объекты запросов в контроллерах. Для этого стоит использовать репозиторий. Хотя в новой архитектуре это допускается."},
    {"code": "        if user and bcrypt.check_password_hash(user.password, args['password']):
            return {
                'id': user.id,
                'token': generate_token(user)
            }",
     "review": "TODO Данную проверку можно поместить в класс пользователя, поскольку данные пользователей напрямую зависят от алгоритма хэширования."},
    {"code": "    def post(self):
        req_parser = reqparse.RequestParser()
        req_parser.add_argument('email', type=str, required=True)
        args = req_parser.parse_args()",
     "review": "TODO судя по всему необходим декоратор @auth_required"},
    {"code": "user = db.session.query(AppUser).filter(AppUser.email==args['email']).first()",
     "review": "TODO Не стоит формировать объекты запросов в контроллерах. Для этого стоит использовать репозиторий. Хотя в новой архитектуре это допускается."},
    {"code": "password_reset = PasswordReset(user=user)
            db.session.add(password_reset)",
     "review": "TODO Этот код и отправку почты можно разместить в службе (сценарии транзакции)."},
    {"code": " db.session.commit()",
     "review": "TODO Не стоит управлять транзакцией внутри каждого обработчика запросов. Это приведет к дублированию кода. Эту функциональность можно вынести в декоратор либо в базовый класс контроллера запросов."},
    {"code": "return {}, 201",
     "review": "TODO Необходимо использовать код успешного завершения запроса по умолчанию централизованно, чтобы не указывать его каждый раз. Код ответа можно поместить в константы."},
    {"code": "    def post(self):
        req_parser = reqparse.RequestParser()
        req_parser.add_argument('code', type=str, required=True)
        req_parser.add_argument('password', type=str, required=True)
        args = req_parser.parse_args()",
     "review": "TODO судя по всему необходим декоратор @auth_required"},
    {"code": "password_reset = db.session.query(PasswordReset
                            ).filter(PasswordReset.code==args['code']
                            ).filter(PasswordReset.date>datetime.now()).first()",
     "review": "TODO Не стоит формировать объекты запросов в контроллерах. Для этого стоит использовать репозиторий. Хотя в новой архитектуре это допускается."},
    {"code": "db.session.commit()",
     "review": "TODO Не стоит управлять транзакцией внутри каждого обработчика запросов. Это приведет к дублированию кода. Эту функциональность можно вынести в декоратор либо в базовый класс контроллера запросов."},
    {"code": "return {}, 200",
     "review": "TODO Необходимо использовать код успешного завершения запроса по умолчанию централизованно, чтобы не указывать его каждый раз. Код ответа можно поместить в константы."}},
    {"code": "req_parser = reqparse.RequestParser()
    req_parser.add_argument('email', type=str, required=True)
    req_parser.add_argument('password', type=str, required=True)",
     "review": "TODO Лучше использовать базовый класс унаследованный от restful.Resource"},
    {"code": "id = db.Column(db.Integer(), primary_key=True)
    email = db.Column(db.String(255), unique=True)
    password = db.Column(db.String(255))
    active = db.Column(db.Boolean())
    is_admin = db.Column(db.Boolean())",
     "review": "TODO перенести весь мапинг SQLAlchemy в components/app/adapters/db/mapping.py"},
    {"code": "id = db.Column(db.Integer(), primary_key=True)
    user_id = db.Column(db.Integer(), db.ForeignKey('app_user.id'))
    code = db.Column(db.String(255), unique=True, default=make_code)
    date = db.Column(db.DateTime(), default=expiration_date)",
     "review": "TODO перенести весь мапинг SQLAlchemy в components/app/adapters/db/mapping.p"},
    {"code": "EMAIL_IN_USE = ({'message': 'User with that email already exists'}, 409)
UNAUTHORIZED = ({'message': 'Authentication is required to access this resource'}, 401)
BAD_CREDENTIALS = ({'message': 'Invalid credentials'}, 401)
FORBIDDEN = ({'message': 'Access to this resource is forbidden'}, 403)
CODE_NOT_VALID = ({'message': 'Valid code is required to reset a password'}, 401)
TOO_MANY_REQUESTS = ({'message': 'Too many requests'}, 429)",
     "review": "TODO Переделать на наследников от класса Exception"},
    {"code": "class Address(db.Model):",
     "review": "TODO: все модели вынести в entities.py"},
    {"code": "    def get_summary(self, include_user=False):
        data = {
            'id': self.id,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'address': self.street_address,
            'zip_code': self.zip_code,
            'city': self.city,
            'country': self.country,
            'created_at': self.created_at,
            'updated_at': self.updated_at
        }

        if include_user:
            data['user'] = {'id': self.user_id, 'username': self.user.username}

        return data",
     "review": "TODO: сериализацию вынести в контроллеры, чтобы возможные изменения не затрагивали сущность"},
    {"code": "class AddressListSerializer(PageSerializer):
    resource_name = 'addresses'",
     "review": "TODO: сериализацию вынести в контроллеры"},
    {"code": "@blueprint.route('/users/addresses', methods=['GET'])
@jwt_required
def list_addresses():
    page_size = request.args.get('page_size', 5)
    page = request.args.get('page', 1)

    user_id = get_jwt_identity()",
     "review": "TODO: обернуть в класс, вынести в контроллеры"},
    {"code": "addresses = Address.query.filter_by(user_id=user_id).order_by(desc(Address.created_at)) \
        .paginate(page=page, per_page=page_size)",
     "review": "TODO: работу с бд вынести в адаптеры"},
    {"code": " first_name = request.json.get('first_name')
    last_name = request.json.get('last_name')
    zip_code = request.json.get('zip_code')
    phone_number = request.json.get('phone_number')
    city = request.json.get('city')
    country = request.json.get('country')
    street_address = request.json.get('address')",
     "review": "TODO: для всех эндпоинтов внедрить модели валидации pydantic"},
    {"code": "db.session.add(address)
    db.session.commit()",
     "review": "TODO: работу с бд вынести в адаптеры"},
    {"code": "app.register_blueprint(blueprint, url_prefix='/api')
@app.shell_context_processor
def make_shell_context():
    return dict(app=app, db=db, User=User, address=Address, order=Order, product=Product,
                tag=Tag, category=Category, comment=Comment, file_upload=FileUpload, tag_image=TagImage,
                category_image=CategoryImage, product_image=ProductImage)",
     "review": "TODO: в этом модуле нужно создать все экземпляры классов и внедрить как зависимости"},
    {"code": "products_categories = \
    db.Table("products_categories",
             db.Column("category_id", db.Integer, db.ForeignKey("categories.id")),
             db.Column("product_id", db.Integer, db.ForeignKey("products.id")))",
     "review": "TODO: все таблицы вынести в tables.py"},
    {"code": "basedir = os.path.abspath(os.path.dirname(__file__))
app = Flask(__name__, root_path=os.getcwd(), static_url_path='/static')

app.config.from_object(Config)
db = SQLAlchemy(app)  # , model_class=BaseModel)
migrate = Migrate(app, db)
cache = Cache()

# cors with defaults, which means allow all domains, it is fine for the moment
cors = CORS(app)
bcrypt = Bcrypt()
jwt = JWTManager(app)",
     "review": "TODO: фабрику Flask реализовать методом, который принимает сервисы и настройки"},
    {"code": "@app.route("/routes")
def site_map():
    links = []
    for rule in app.url_map._rules:
        links.append({'ulr': rule.rule, 'view': rule.endpoint})
    return jsonify(links), 200",
     "review": "TODO: вынести в контроллеры"},
    {"code": "cart_items = request.json.get('cart_items')
    product_ids = [ci['id'] for ci in cart_items]
    products = db.session.query(Product).filter(Product.id.in_(product_ids)).all()",
     "review": "TODO: логику перенести в слой сервисов"},
    {"code": "def get_or_create(session, model, defaults=None, **kwargs):
    instance = session.query(model).filter_by(**kwargs).first()
    if instance:
        return instance, False
    else:
        params = dict((k, v) for k, v in kwargs.iteritems() if not isinstance(v, ClauseElement))
        params.update(defaults or {})
        instance = model(**params)
        session.add(instance)
        return instance, True",
     "review": "TODO: все операции с БД вынести в repositories.py"},
    {"code": "class BaseModel(Model):
    id = Column(Integer, primary_key=True)
    created_at = Column(DateTime, nullable=False, default=datetime.utcnow)
    def get_or_default(self, ident, default=None):
        return self.get(ident) or default",
     "review": "TODO: вынести в entities.py и mapping.py (при переходе на императивный ORM)"},
    {"code": "class PageSerializer(object):
    def __init__(self, pagination_obj, **kwargs):
        if type(pagination_obj) != Pagination:
            raise EnvironmentError()
        self.data = {}
        self.items = [resource.get_summary(**kwargs) for resource in pagination_obj.items]
        self.data['total_items_count'] = pagination_obj.total
        self.data['offset'] = (pagination_obj.page - 1) * pagination_obj.per_page
        self.data['requested_page_size'] = pagination_obj.per_page
        self.data['current_page_number'] = pagination_obj.page

        self.data['prev_page_number'] = pagination_obj.prev_num or 1
        self.data['total_pages_count'] = pagination_obj.pages

        self.data['has_next_page'] = pagination_obj.has_next
        self.data['has_prev_page'] = pagination_obj.has_prev

        self.data['next_page_number'] = pagination_obj.next_num or self.data['current_page_number']

        self.data['next_page_url'] = '%s?page=%d&page_size=%d' % (
            request.path, self.data['next_page_number'], self.data['requested_page_size'])

        self.data['prev_page_url'] = '%s?page=%d&page_size=%d' % (
            request.path, self.data['prev_page_number'], self.data['requested_page_size'])",
     "review": "TODO: вынести в контроллеры"},
    {"code": "MONGODB_SETTINGS = {'DB': 'library'}  
PASSWORD_SECRET = 'secret_for_ensure_password_security'
TOKEN_SECRET = 'secret_for_ensure_token_security'",
     "review": "TODO: секреты передавать через переменные окружения настройки хранить в settings и использовать BaseSettins из Pydantic"},
    {"code": "@route("/roles", tags=tags)
class RoleListAPI:
    @staticmethod
    @description("Get roles")
    async def get(
        page: int = Header(default=1),
        _: int = Header(default=10),
        user: User = Depends(role_perms),
    ) -> Page[RoleSafe]:
        # Role - необходимо использовать DI + паттерн репозиторий для получения данных
        data = await Role.get_all()
        total = len(data)
        page = Page(total=total, page=1, pages=1, perpage=total, data=data)
        return page",
     "review": "TODO: необходимо вынести в adapters/api все что связанно с web фреймвороком"},
    {"code": "def validate_payload_parameters(input_payload=None):
    if input_payload:
        parameters = input_payload.get('parameters', None)
        # print(parameters)
        if parameters:
            return True
    return False",
     "review": "TODO: Валидация http параметров необходимо производить в контроллерах"},
    {"code": "user = User.query.filter_by(username=token).first()
        location = Location.query.filter_by(name=name).first()
        if user and location and user.location:
            speech = 'Taking you to Location: %r with co-ordinates(%r, %r)'%(location.name, str(location.latitude), str(location.longitude))
            if  location.campus and user.location.campus and user.location.campus.id == location.campus.id:
                speech += ' is located at Campus: %r'%(location.campus.name)
            else:
                speech='You are not in the same campus to View Routes!'
                parameters['noRoute'] = 'true'
            parameters['fromLocation'] = user.location.to_dict()
            parameters['toLocation'] = location.to_dict()
            return speech, parameters
        elif not user:
            return 'Invalid User Token!', parameters
        elif not location:
            return 'Not a valid Location', parameters
        else:
            return 'User has no location to route to!', parameters",
     "review": "TODO: необходимо вынести в слой адаптеров, работаь через репозитории и интерфейсы из сервисов"},
    {"code": "authenticated, token = validate_auth_context(input_json)
        if authenticated:
            # process event add here
            status = validate_input_fetch_data_and_add_event(event_date=s_date, participant_name=participant_name, location_name=location_name, event_time=s_time, creator=token)
            # bring logic to validate and add meeting event
            resp_string = ('Added!' + resp_string) if status else 'Not Added Event!!'
        else:
            resp_string = 'Not authenticated to Add Event!!'",
     "review": "TODO: логику проверки auth лучше вынести отдельно"},
    {"code": "now = datetime.datetime.now()
    title = form.get("title", None)
    description = form.get("description", None)
    e_start = form.get("validFrom", None)
    e_end = form.get("validTill", None)
    category = form.get("category", None)",
     "review": "TODO: работу с формой и параметрами вынести в слой адаптеров"},
    {"code": "now = datetime.datetime.now()
    title = form.get("title", None)
    description = form.get("description", None)
    e_start = form.get("eventStart", None)
    e_end = form.get("eventEnd", None)
    participant_ids = form.get("participantIds", '')
    location_id = form.get('locationId', None)",
     "review": "TODO: работу с формой и параметрами вынести в слой адаптеров"},
    {"code": "if not self.is_lecture_attended(course):
            self.lecture_attendance.append(course)
            db.session.commit()",
     "review": "TODO: можно вынести часть логики в сервис"},
    {"code": "sql = f'''
            SELECT count
            FROM {lecturer_lectures_table_name}
            WHERE lecturer_id = {lecturer.id}
            AND course_id = {course.id}
            LIMIT 1
        '''
        result = db.session.execute(sql)",
     "review": "TODO: убрать чистый SQL по коду"},
    {"code": "sql = f'''
                SELECT firstname, lastname, othername, reg_no
                FROM students
                INNER JOIN {table_name} ON {table_name}.student_id = students.id
                WHERE students.department_id = {department.id}
                AND {table_name}.course_id = {course.id}
            '''
            result = db.session.execute(sql)",
     "review": "TODO: вынести запросы к бд из сервиса, использовать sqlalchemy core"},
    {"code": "@staticmethod
    def create_lecturer(data):
        response = {}
        name = data['name']
        email = data['email']
        department_code = data['department']
        password = data['password']",
     "review": "TODO: во всех сервисах внедрить репозитории для работы с хранилищем (БД)"},
    {"code": "@click.group("cli")
@click.option("--config", help="Set the path to the config file")
@click.pass_context
def cli(ctx, config):
    if config:
        os.environ[ENV_CONFIG_FILE] = os.path.abspath(config)
    warnings.filterwarnings(
        "ignore",
        message=".*https://flask-limiter.readthedocs.io#configuring-a-storage-backend.*",)
    ctx.obj = {"app": create_app()}",
     "review": "TODO: выделить cli в отдельный адаптер и произвести настройку через отдельный композит"},
    {"code": "@cli.command("run")
@click.option("-p", "--port", help="Port to use (default: 5000)", default=5000)
@click.option("--tree", help="Tree ID", default=None)
@click.pass_context
def run(ctx, port, tree):
    """Run the app."""
    app = ctx.obj["app"]
    app.run(port=port, threaded=True)",
     "review": "TODO: оформить инициализацию приложения в отдельном композите согласно стандартам"},
    {"code": "def check_database(db_handle: DbWriteBase, progress_cb: Optional[Callable] = None):
    i = 0
    def progress(i):
        total = 20
        if progress_cb:
            progress_cb(current=i, total=total)
        i += 1
        return i",
     "review": "TODO: вынести в сервис на уровне ядра"},
    {"code": "print(_("Unknown option: %s") % option, file=sys.stderr)
                print(
                    _("   Valid options are:")
                    + _(", ").join(list(self.options_dict.keys())),  # Arabic OK
                    file=sys.stderr,
                )
                print(
                    _(
                        "   Use '%(donottranslate)s' to see description "
                        "and acceptable values"
                    )
                    % {"donottranslate": "show=option"},
                    file=sys.stderr,
                )",
     "review": "TODO: print заменить на logging.log"},
    {"code": "def get_db_manager(tree: Optional[str]) -> WebDbManager:
    """Get an appropriate WebDbManager instance."""
    return WebDbManager(
        dirname=tree,
        username=current_app.config["POSTGRES_USER"],
        password=current_app.config["POSTGRES_PASSWORD"],
        create_if_missing=False,
        ignore_lock=current_app.config["IGNORE_DB_LOCK"],
    )",
     "review": "TODO: вынести в отдельный адаптер database в слое адаптеров для получения данных использовать паттерн репозиторий, интерфейсы описать в слое ядра и реализовать в репозиториях"},
    {"code": "def add_user(
    name: str,
    password: str,
    fullname: Optional[str] = None,
    email: Optional[str] = None,
    role: Optional[int] = None,
    tree: Optional[str] = None,
)",
     "review": "TODO: вынести в репозиторий на слое адаптеров"},
    {"code": "class DefaultConfig(object):
    PROPAGATE_EXCEPTIONS = True
    SEARCH_INDEX_DIR = "indexdir"  # deprecated!
    SEARCH_INDEX_DB_URI = ""
    EMAIL_HOST = "localhost"
    EMAIL_PORT = "465"
    EMAIL_HOST_USER = ""
    EMAIL_HOST_PASSWORD = ""
    EMAIL_USE_TLS = True
    DEFAULT_FROM_EMAIL = ""
    BASE_URL = "http://localhost/"
    CORS_EXPOSE_HEADERS = ["X-Total-Count"]
    STATIC_PATH = "static"
    THUMBNAIL_CACHE_CONFIG = {
        "CACHE_TYPE": "FileSystemCache",
        "CACHE_DIR": str(Path.cwd() / "thumbnail_cache"),
        "CACHE_THRESHOLD": 1000,
        "CACHE_DEFAULT_TIMEOUT": 0,
    }
    POSTGRES_USER = None
    POSTGRES_PASSWORD = None
    POSTGRES_HOST = "localhost"
    POSTGRES_PORT = "5432"
    IGNORE_DB_LOCK = False
    CELERY_CONFIG: Dict[str, str] = {}
    MEDIA_BASE_DIR = ""
    MEDIA_PREFIX_TREE = False
    REPORT_DIR = str(Path.cwd() / "report_cache")
    EXPORT_DIR = str(Path.cwd() / "export_cache")
    NEW_DB_BACKEND = "sqlite"
    RATE_LIMIT_MEDIA_ARCHIVE = "1 per day"
    REGISTRATION_DISABLED = False
    LOG_LEVEL = "INFO"
    LLM_BASE_URL = None
    LLM_MODEL = ""
    LLM_MAX_CONTEXT_LENGTH = 50000
    VECTOR_EMBEDDING_MODEL = """,
     "review": "TODO: разделить на отдельные классы конфигов и разложить по соответствующим адаптерам"},
    {"code": "class DefaultConfigJWT(object):
    JWT_TOKEN_LOCATION = ["headers", "query_string"]
    JWT_ACCESS_TOKEN_EXPIRES = datetime.timedelta(minutes=15)
    JWT_REFRESH_TOKEN_EXPIRES = False
    JWT_ERROR_MESSAGE_KEY = "message"",
     "review": "TODO: разделить на отдельные классы конфигов и разложить по соответствующим адаптерам"},
    {"code": "class Change(Base):
    __tablename__ = "changes"
    __table_args__ = (PrimaryKeyConstraint("id", "connection_id"),)
    id = Column(Integer)
    connection_id = Column(Integer, ForeignKey("connections.id"), index=True)
    obj_class = Column(Text)
    trans_type = Column(Integer)
    obj_handle = Column(Text)
    ref_handle = Column(Text)
    old_data = Column(LargeBinary)
    new_data = Column(LargeBinary)
    timestamp = Column(BigInteger, index=True)
    connection = relationship("Connection", back_populates="changes")",
     "review": "TODO: перенести в адаптер database"},
    {"code": "def create_celery(app):
    celery = current_celery_app
    celery.conf.name = app.import_name
    celery.conf.update(app.config["CELERY_CONFIG"])",
     "review": "TODO: перенести в адаптер"},
    {"code": "class Request:
    def __getattr__(self, item):
        return getattr(request, item)
class APIView(MethodView):
    def __init__(self, request) -> None:
        self.request = request or Request()",
     "review": "TODO: отсутсвуют типы данных, в возвращаемых функциях указаны частично"},
    {"code": "class ContentType:
    MULTIPART_FORM_DATA = 'multipart/form-data'
    APPLICATION_JSON = 'application/json'",
     "review": "TODO: Не похоже на utils"},
    {"code": "class HTTPStatus:
    HTTP_100_CONTINUE = 100
    HTTP_101_SWITCHING_PROTOCOLS = 101
    HTTP_200_OK = 200
    HTTP_201_CREATED = 201
    HTTP_202_ACCEPTED = 202
    HTTP_203_NON_AUTHORITATIVE_INFORMATION = 203
    HTTP_204_NO_CONTENT = 204
    HTTP_205_RESET_CONTENT = 205
    HTTP_206_PARTIAL_CONTENT = 206
    HTTP_207_MULTI_STATUS = 207
    HTTP_300_MULTIPLE_CHOICES = 300
    HTTP_301_MOVED_PERMANENTLY = 301
    HTTP_302_FOUND = 302
    HTTP_303_SEE_OTHER = 303
    HTTP_304_NOT_MODIFIED = 304
    HTTP_305_USE_PROXY = 305
    HTTP_306_RESERVED = 306
    HTTP_307_TEMPORARY_REDIRECT = 307
    HTTP_400_BAD_REQUEST = 400
    HTTP_401_UNAUTHORIZED = 401
    HTTP_402_PAYMENT_REQUIRED = 402
    HTTP_403_FORBIDDEN = 403
    HTTP_404_NOT_FOUND = 404
    HTTP_405_METHOD_NOT_ALLOWED = 405
    HTTP_406_NOT_ACCEPTABLE = 406
    HTTP_407_PROXY_AUTHENTICATION_REQUIRED = 407
    HTTP_408_REQUEST_TIMEOUT = 408
    HTTP_409_CONFLICT = 409
    HTTP_410_GONE = 410
    HTTP_411_LENGTH_REQUIRED = 411
    HTTP_412_PRECONDITION_FAILED = 412
    HTTP_413_REQUEST_ENTITY_TOO_LARGE = 413
    HTTP_414_REQUEST_URI_TOO_LONG = 414
    HTTP_415_UNSUPPORTED_MEDIA_TYPE = 415
    HTTP_416_REQUESTED_RANGE_NOT_SATISFIABLE = 416
    HTTP_417_EXPECTATION_FAILED = 417
    HTTP_422_UNPROCESSABLE_ENTITY = 422
    HTTP_423_LOCKED = 423
    HTTP_424_FAILED_DEPENDENCY = 424
    HTTP_428_PRECONDITION_REQUIRED = 428
    HTTP_429_TOO_MANY_REQUESTS = 429
    HTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE = 431
    HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS = 451
    HTTP_500_INTERNAL_SERVER_ERROR = 500
    HTTP_501_NOT_IMPLEMENTED = 501
    HTTP_502_BAD_GATEWAY = 502
    HTTP_503_SERVICE_UNAVAILABLE = 503
    HTTP_504_GATEWAY_TIMEOUT = 504
    HTTP_505_HTTP_VERSION_NOT_SUPPORTED = 505
    HTTP_507_INSUFFICIENT_STORAGE = 507
    HTTP_511_NETWORK_AUTHENTICATION_REQUIRED = 511",
     "review": "TODO: Не похоже на utils"},
    {"code": "__version__ = '2.2.0'
DEBUG = os.environ.get('DEBUG', False)
MODEL_NAME = os.environ.get('MODEL_NAME', 'model.joblib')
ENVIRONMENT = os.environ.get('ENVIRONMENT', 'local')
MODEL_TYPE = os.environ.get('MODEL_TYPE', 'SKLEARN_MODEL')
SERVICE_START_TIMESTAMP = time()
application = flask.Flask(__name__)
application.logger.setLevel(logging.DEBUG if DEBUG else logging.ERROR)
application.json_encoder = ExtendedEncoder
model = ModelFactory.create_model(MODEL_NAME, MODEL_TYPE)
application.logger.info('ENVIRONMENT: {}'.format(ENVIRONMENT))
application.logger.info('Using template version: {}'.format(__version__))
application.logger.info('Loading model...')
model.load()",
     "review": "TODO: Монолит, все в одном месте, логика, точка входа, роутинг"},
    {"code": "app = create_app(os.environ.get('FLASK_ENV'))",
     "review": "TODO: вынести в настройки с использованием BaseSettings"},
    {"code": "@app.cli.command()
def run():
    app.run(host='0.0.0.0')
@app.cli.command()
def test():
    tests = unittest.TestLoader().discover('test', pattern='test*.py')
    result = unittest.TextTestRunner(verbosity=2).run(tests)
    return result.wasSuccessful()",
     "review": "TODO: вынести в адаптер cli"},
    {"code": "@app.after_request
def log_info(response):
    date = arrow.now('Africa/Lagos')
    if os.environ.get('FLASK_ENV') is 'prod':
        ip = request.headers.get(app.config['REAL_IP'])
    else:
        ip = request.remote_addr
    log_details = {
        'date': date.format(),
        'ip': ip,
        'browser': request.user_agent.browser,
        'device': request.user_agent.platform,
        'status_code': response.status_code,
        'path': request.path,
        'method': request.method,
    }
    response.headers.add('Access-Control-Allow-Origin', '*')
    response.headers.add('Access-Control-Allow-Headers', 'Content-Type, x-auth-token')
    stream_logger.debug(log_details)
    if not app.debug:
        request_logger.info(log_details)
    return response
",
     "review": "TODO: вынести в адаптер logger"},
    {"code": "db = SQLAlchemy()
mail = Mail()
authorizations = {
    'apiKey': {
        'type': 'apiKey',
        'in': 'header',
        'name': 'x-auth-token'
    }
}",
     "review": "TODO: экземпляры подключений, севрисов итд прокидывать через DI"},
    {"code": "def create_app(config_name):
    app = Flask(__name__)
    app.wsgi_app = ProxyFix(app.wsgi_app)
    app.config.from_object(config_by_env[config_name])
    db.init_app(app)
    mail.init_app(app)
    api.init_app(app)",
     "review": "TODO: фабрика должна принимать сервисы и регистрировать контроллеры"},
    {"code": "admin_api = Namespace('admins', description='Endpoints to manage admin operations')",
     "review": "TODO: регистрация эндпоинтов необходимо вынести в фабрику создания app"},
    {"code": "admin_reg = admin_api.model('Admin Registration', {
    'name': fields.String(required=True, description='Admin\'s name'),
    'email': fields.String(required=True, description='Admin\'s email'),
    'password': fields.String(required=True, description='Admin\'s password')
})",
     "review": "TODO: модели стоит вынести в отдельный пакет"},
    {"code": "@admin_api.route('/signup')
class Signup(Resource):
    @admin_api.doc('Register a new Admin')
    @admin_api.response(201, 'New Admin successfully registered')
    @admin_api.expect(admin_reg)
    def post(self):
        data = request.json
        payload = admin_api.payload or data
        schema = NewAdminSchema()",
     "review": "TODO: регистрация эндпоинтов необходимо вынести в фабрику создания app"},
    {"code": "response, code = AdminsService.create(data=new_payload)
        return response, code",
     "review": "TODO: сервисы необходимо прокидывать как зависимость"},
    {"code": "@admin_api.route('/exam/oar/<string:session>/<string:semester>/<string:course>/<string:department>')",
     "review": "TODO: вынести роут в константы"},
    {"code": "class Admin(db.Model):
    __tablename__ = 'admins'
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    name = db.Column(db.String(128))
    email = db.Column(db.String(128))
    password_hash = db.Column(db.String(128))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    def __init__(self, name, email, password):
        self.name = name.title()
        self.email = email
        self.password = password
",
     "review": "TODO: в стандартах используется императивный стиль ORM"},
    {"code": "if not self.is_lecture_attended(course):
            self.lecture_attendance.append(course)",
     "review": "TODO: можно вынести часть логики в сервис"},
    {"code": "sql = f'''
                SHOW COLUMNS
                FROM {student_lectures_table_name}
                LIKE 'day1'
            '''",
     "review": "TODO: убрать чистый SQL по коду"},
    {"code": "sql = f'''
                    ALTER TABLE {student_lectures_table_name}
                    ADD day1 INT NOT NULL DEFAULT 0
                '''",
     "review": "TODO: убрать чистый SQL по коду"},
    {"code": "sql = f'''
                UPDATE {lecturer_lectures_table_name}
                SET count = count + 1
                WHERE lecturer_id = {self.id}
                AND course_id = {course.id}
            '''",
     "review": "TODO: убрать чистый SQL по коду"},
    {"code": "sql = f'''
                SELECT count
                FROM {lecturer_lectures_table_name}
                WHERE lecturer_id = {self.id}
                AND course_id = {course.id}
                LIMIT 1
            '''",
     "review": "TODO: убрать чистый SQL по коду"},
    {"code": "sql = f'''
                SHOW COLUMNS
                FROM {student_lectures_table_name}
                LIKE 'day{lecture_count}'
            '''",
     "review": "TODO: убрать чистый SQL по коду"},
    {"code": "sql = f'''
                    ALTER TABLE {student_lectures_table_name}
                    ADD day{lecture_count} INT NOT NULL DEFAULT 0
                '''",
     "review": "TODO: убрать чистый SQL по коду"},
    {"code": "session = os.environ.get('CURRENT_REGISTERED_COURSES_SESSION')
semester = os.environ.get('CURRENT_REGISTERED_COURSES_SEMESTER')
registered_courses_table_name = select_table_name(f'REGISTERED_COURSES_{semester}_{session}')
exam_table_name = select_table_name(f'STUDENTS_EXAM_{semester}_{session}')
student_lectures_table_name = select_table_name(f'STUDENT_LECTURES_{semester}_{session}')
lecturer_lectures_table_name = select_table_name(f'LECTURER_LECTURES_{semester}_{session}')",
     "review": "TODO: лучше использовать BaseSettings"},
    {"code": "registered_courses = db.Table(registered_courses_table_name,
    db.Column('student_id', db.Integer, db.ForeignKey('students.id'), primary_key=True),
    db.Column('course_id', db.Integer, db.ForeignKey('courses.id'), primary_key=True))",
     "review": "TODO: вынести в модуль tables"},
    {"code": "StudentLogin = namedtuple('StudentLogin', [
    'reg_no',
    'password'
])
LecturerLogin = namedtuple('LecturerLogin', [
    'email',
    'password'
])
HODLogin = namedtuple('HODLogin', [
    'email',
    'password'
])
AdminLogin = namedtuple('AdminLogin', [
    'email',
    'password'
])",
     "review": "TODO: заменить namedtuple на dataclass и вынести в другой модуль"},
    {"code": "try:
            lecturer = Lecturer.query.filter_by(email=email).first()",
     "review": "TODO: всю работу с БД вынести в репозитории"},
    {"code": "class Config:
    FLASK_DEBUG = True
    SECRET_KEY = os.environ.get('SECRET_KEY')
    JWT_SECRET_KEY = os.environ.get('JWT_SECRET_KEY')
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    MAIL_SERVER = os.environ.get('MAIL_SERVER')
    MAIL_PORT = os.environ.get('MAIL_PORT')
    MAIL_USERNAME = os.environ.get('MAIL_USERNAME')
    MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')
    MAIL_USE_TLS = os.environ.get('MAIL_USE_TLS', False)
    ADMINS = [f'no-reply@{MAIL_SERVER}.com']
    REAL_IP = 'X-Real-IP'
    PROPAGATE_EXCEPTIONS = True",
     "review": "TODO: для хранения настроек нужно использовать BaseSettings из pydantic"},
    {"code": "print(DevelopmentConfig.SQLALCHEMY_DATABASE_URI)",
     "review": "TODO: print заменить на logger"}
]